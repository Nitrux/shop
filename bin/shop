#! /bin/bash


    # Aborts the application with an error message.

_e () { echo "$*"; exit 1; }


    # Concatenate a file.

add () {
    # $1 might be specified in the following formats:
    #   <file>
    #   <repo>:<file>
    IFS=: read a b <<< "$1"
    test "$b" || { cat "$a"; return; }

    # If the package is not installed, attempt to install it.
    test -d "$shop_root/$a/lib/$b" || i "$a"
    cat "$shop_root/$a/lib/$b"
}


    # Assembles a script from a list of packages.

b () {
    def () { local K; for K; do eval "$K () { $K+=( \"\$@\" ); __bcf_g__=$K; }"; done; }
      , () { "$__bcf_g__" "$@"; }   # These lines come from bcf.

    # The groups in shopfile.
    def Main Target Include
        source ./shopfile

    # Override Target if needed.
    Target="${1:-${Target}}"

    # Use the shebang from $Main.
    read sb < "$Main"
        echo "$sb" > "$Target"          # We want to truncate this file (>) as it might not
                                        # be empty (as in a failed build, for instance).

    for P in "${Include[@]}" "$Main"    # Append all passed files to $Target.
        do add "$P"; done >> "$Target"

    chmod +x "$Target"
    echo "'$Target': Built."
}


    # Installs a package.

i () {
    # P might be specified in the following formats:
    #   <repo>
    #   <repo>:<tag>
    for P; do
        test -d "$P" && continue     # The package is already installed.

        IFS=: read r t <<< "$P"
        test "$t" && { git clone --depth 1 "https://github.com/$r" -b "$t" "$shop_root/$r:$t"; } \
                  || { git clone --depth 1 "https://github.com/$r" "$shop_root/$r"; }

        test $? = 0 || exit 1

        find "$shop_root/$P" -maxdepth 1 -mindepth 1 -type f -perm -u+x \
            -exec ln -rfs {} "$shop_root/.bin/" \;
    done
}


    # Updates the given package or all packages.

u () {
    test $# = 0 \
        && set "$shop_root/"*/*

    for P; do (cd "$P"; git pull); done
}


    # Ensures the given packages are not present in the system.

r () { for P; do rm -rf "$shop_root/$P"; done; }


    # Lists installed packages.

l () { shopt -s nullglob; (cd "$shop_root"; printf "%s\n" */*); }




    # Dispatcher.

shop_root=~/.shop
mkdir -p "$shop_root/.bin"

case "$1" in
    ( [iurlb] ) "$@";;

    ( * )       _ () { echo -e "$*"; }
                _ "Usage: shop [\e[3;32mCMD\e[m]"
                _ ""
                _ "\e[3;32mCMD\e[m is any of:"
                _ ""
                _ "  i [pkgs]   Install the given packages."
                _ "             shop understands this format: \e[3;32m<user/repo>[/tag]\e[m."
                _ "             If \e[3;32m/tag\e[m is given, the package will be installed"
                _ "             as \e[3;32muser/repo-tag\e[m. Otherwise, as \e[3;32muser/repo\e[m."
                _ "  u [pkgs]   Update all or the given packages."
                _ "  r [pkgs]   Remove the given packages."
                _ "  l          List installed packages.";;
esac
